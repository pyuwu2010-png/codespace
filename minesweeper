import time, random, sys, pyautogui
from PIL import Image

pyautogui.FAILSAFE=True
pyautogui.PAUSE=0.01

board_region=(269,211,719,384)
cols=30
rows=16
CLICK_DELAY=0.02
LOOP_DELAY=0.16
SAFE_FIRST_CLICK=True

def norm_region(r):
    a,b,c,d=r
    if c>a and d>b:
        return a,b,c-a,d-b
    return a,b,c,d

BL,BT,BW,BH=norm_region(board_region)
tile= min(BW//cols, BH//rows)
REGION=(BL,BT,tile*cols,tile*rows)

def center(r,c):
    return BL+c*tile+tile//2, BT+r*tile+tile//2

def click(r,c):
    x,y=center(r,c)
    pyautogui.click(x,y)
    time.sleep(CLICK_DELAY)

def tile_img(img,r,c):
    L=c*tile; T=r*tile
    return img.crop((L,T,L+tile,T+tile))

def classify(t):
    t=t.convert('RGB')
    w,h=t.size
    pix=t.load()
    cr,cg,cb=pix[w//2,h//2]
    if cr<110 and cg<110 and cb<110:
        return None
    if cb>150 and cr<80 and cg<80:
        return 1
    if cg>150 and cr<80 and cb<80:
        return 2
    if cr>150 and cg<80 and cb<80:
        return 3
    if cb>120 and cr<60 and cg<60:
        return 4
    if cr>110 and cg<70 and cb<70:
        return 5
    if cg>100 and cb>100 and cr<100:
        return 6
    if cr<80 and cg<80 and cb<80:
        return 7
    r0=sum(pix[x,y][0]+pix[x,y][1]+pix[x,y][2] for x in range(1,w-1) for y in range(1,h-1))
    if r0/(tile*tile)>160:
        return 0
    return None

def scan():
    s=pyautogui.screenshot(region=REGION)
    b=[[None]*cols for _ in range(rows)]
    for r in range(rows):
        for c in range(cols):
            b[r][c]=classify(tile_img(s,r,c))
    return b

def scan_one(r,c):
    i=pyautogui.screenshot(region=(BL+c*tile,BT+r*tile,tile,tile))
    return classify(i)

def neigh(r,c):
    for dr in(-1,0,1):
        for dc in(-1,0,1):
            if dr or dc:
                nr, nc=r+dr,c+dc
                if 0<=nr<rows and 0<=nc<cols:
                    yield nr,nc

def rules(b,m):
    clk=set()
    changed=False
    for r in range(rows):
        for c in range(cols):
            v=b[r][c]
            if isinstance(v,int) and v>=0:
                n=list(neigh(r,c))
                h=[p for p in n if b[p[0]][p[1]] is None and p not in m]
                fm=sum((p in m)for p in n)
                if h:
                    if fm==v:
                        for p in h: clk.add(p)
                    if fm+len(h)==v:
                        for p in h:
                            if p not in m:
                                m.add(p); changed=True
    for r,c in clk:
        if scan_one(r,c) is None:
            click(r,c)
            time.sleep(0.02)
    return bool(clk) or changed

def random_safe(b,m):
    h=[(r,c)for r in range(rows)for c in range(cols)if b[r][c] is None and (r,c) not in m]
    if not h: return None
    def sc(p):
        rr,cc=p
        return sum(isinstance(b[nr][nc],int)for nr,nc in neigh(rr,cc))+random.random()*0.4
    h.sort(key=sc)
    return h[0]

def play():
    if SAFE_FIRST_CLICK:
        click(rows//2,cols//2)
        time.sleep(0.4)
    m=set()
    np=0
    for _ in range(3000):
        b=scan()
        if rules(b,m):
            np=0
            time.sleep(0.2)
            continue
        r=random_safe(b,m)
        if r is None: break
        sr=scan_one(*r)
        if sr is None:
            click(*r)
            np+=1
            time.sleep(0.3)
        else:
            np=0
        if np>5:
            h=[(rr,cc)for rr in range(rows)for cc in range(cols)if b[rr][cc] is None and (rr,cc) not in m]
            if not h: break
            click(*random.choice(h))
            np=0
        time.sleep(LOOP_DELAY)

if __name__=="__main__":
    if input("yes? ").strip().lower()!="yes": sys.exit()
    try: play()
    except KeyboardInterrupt: pass
    except pyautogui.FailSafeException: pass
